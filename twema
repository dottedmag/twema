#!/usr/bin/python
# -*- coding: utf-8 -*-

import sqlite3
import sys
import logging
import json
import datetime

import twitter
import os
import os.path

import smtplib

import subprocess

from email.message import EmailMessage

confdir = os.path.join(os.environ.get('HOME'), '.twema')
if not os.path.isdir(confdir):
    os.mkdir(confdir)

oauth_filename = os.path.join(confdir, 'oauth')
status_filename = os.path.join(confdir, 'tweets.db')

exec(open("keys.py").read())

FROM_NAME='Twitter Robot'
FROM='robot@dottedmag.net'
TO='dottedmag@dottedmag.net'

logging.basicConfig(level=logging.ERROR)
tl = logging.getLogger('twema.tweet')

db = sqlite3.connect(status_filename)

def prepare_schema():
    db.execute('CREATE TABLE IF NOT EXISTS tweets (id INTEGER PRIMARY KEY, content NOT NULL, sent NOT NULL DEFAULT 0)')
    db.commit()
prepare_schema()

def save_tweet(content):
    db.execute('INSERT INTO tweets (id, content) VALUES (?, ?)', (content['id'], json.dumps(content)))
    db.commit()

def get_latest_saved_id():
    dt = db.execute('SELECT MAX(id) FROM tweets').fetchone()
    if dt:
        return dt[0]

def get_unsent_tweets():
    return db.execute('SELECT id, content FROM tweets WHERE sent=0 ORDER BY id').fetchall()

def mark_as_sent(_id):
    db.execute('UPDATE tweets SET sent=1 WHERE id=?', (_id, ))
    db.commit()

def get_tweets_after(twitter, _id):
    sts = []
    statuses = twitter.statuses.home_timeline(count=200, since_id=_id)
    tl.debug('Obtained '+str(len(statuses))+' tweets')
    while len(statuses):
        sts.extend(statuses)
        least_id = min(statuses, key=lambda s: s['id'])['id']
        statuses = twitter.statuses.home_timeline(count=200, since_id=_id, max_id=least_id-1, tweet_mode='extended')
        tl.debug('Obtained '+str(len(statuses))+' tweets')
    return sts

def get_latest_tweets(twitter):
    return twitter.statuses.home_timeline(count=10, tweet_mode='extended')

def connect_twitter():
    tl.debug('Connecting to Twitter')
    if not os.path.exists(oauth_filename):
        twitter.oauth_dance('twema', CONSUMER_KEY, CONSUMER_SECRET, oauth_filename)
    oauth_token, oauth_token_secret = twitter.oauth.read_token_file(oauth_filename)
    oa = twitter.oauth.OAuth(oauth_token, oauth_token_secret, CONSUMER_KEY, CONSUMER_SECRET)
    return twitter.api.Twitter(auth=oa, secure=True, api_version='1.1', domain='api.twitter.com')

def refresh_tweets():
    last_id = get_latest_saved_id()
    twitter = connect_twitter()
    if last_id:
        tl.info('Updating tweets after '+str(last_id))
        tweets = get_tweets_after(twitter, last_id)
    else:
        tl.info('No saved tweets found, obtaining last 10')
        tweets = get_latest_tweets(twitter)

    for tweet in tweets:
        tl.info('Saving tweet '+str(tweet['id'])+' into DB')
        save_tweet(tweet)

def print_mentions():
    twitter = connect_twitter()
    tweets = twitter.statuses.mentions_timeline(count=10)
    print(tweets)

def parse_twitter_timestamp(stamp):
    return datetime.datetime.strptime(stamp, '%a %b %d %H:%M:%S +0000 %Y')

def normws(text):
    return ' '.join(text.split())

def compose_msg(tweet):
    msg = EmailMessage()
    msg['Subject'] = normws('@'+tweet['user']['screen_name']+': '+tweet['full_text'])
    msg['To'] = TO

    msg.set_content('''%(name)s @%(screen_name)s %(date)s

%(text)s

Link: https://twitter.com/%(screen_name)s/status/%(id)s
User: https://twitter.com/%(screen_name)s
Reply: https://twitter.com/intent/tweet?in_reply_to=%(id)s
Retweet: https://twitter.com/intent/retweet?tweet_id=%(id)s
Favorite: https://twitter.com/intent/favorite?tweet_id=%(id)s
''' % {'screen_name': tweet['user']['screen_name'],
       'name': tweet['user']['name'],
       'text': tweet['text'],
       'date': parse_twitter_timestamp(tweet['created_at']).strftime('%d.%m.%Y %H:%M:%S'),
       'id': tweet['id']}, subtype='plain')
    return msg

def send_tweet(tweet):
    msg = compose_msg(tweet)
    p = subprocess.Popen(['/usr/sbin/sendmail', '-t', '-oi', '-f', FROM, '-F', FROM_NAME], stdin=subprocess.PIPE)
    p.communicate(bytes(msg))
    return p.returncode == 0

def send_tweets():
    for (_id, content) in get_unsent_tweets():
        if send_tweet(json.loads(content)):
            tl.info('Marking tweet '+str(_id)+' as sent')
            mark_as_sent(_id)

if sys.argv[1] == 'mentions':
    print_mentions()
if sys.argv[1] == 'refresh':
    refresh_tweets()
if sys.argv[1] == 'send':
    send_tweets()
